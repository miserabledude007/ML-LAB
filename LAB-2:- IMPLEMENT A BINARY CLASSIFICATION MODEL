import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow.keras import layers
from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt

# Load dataset
train_df = pd.read_csv("https://download.mlcc.google.com/mledu-datasets/california_housing_train.csv")
test_df = pd.read_csv("https://download.mlcc.google.com/mledu-datasets/california_housing_test.csv")

# Shuffle the training set
train_df = train_df.reindex(np.random.permutation(train_df.index))

# Normalize the training set
train_df_mean = train_df.mean()
train_df_std = train_df.std()
train_df_norm = (train_df - train_df_mean) / train_df_std

# Normalize the test set
test_df_mean = test_df.mean()
test_df_std = test_df.std()
test_df_norm = (test_df - test_df_mean) / test_df_std

# Define the threshold for classification
threshold = 265000
train_df_norm["median_house_value_is_high"] = (train_df["median_house_value"] > threshold).astype(float)
test_df_norm["median_house_value_is_high"] = (test_df["median_house_value"] > threshold).astype(float)

# Define inputs for the model
inputs = {
    'median_income': tf.keras.Input(shape=(1,)),
    'total_rooms': tf.keras.Input(shape=(1,))
}

# Create the model
def create_model(my_inputs, my_learning_rate, METRICS):
    concatenated_inputs = tf.keras.layers.Concatenate()(my_inputs.values())
    dense = layers.Dense(units=1, activation='sigmoid')(concatenated_inputs)
    model = tf.keras.Model(inputs=my_inputs, outputs=dense)
    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=my_learning_rate),
                  loss=tf.keras.losses.BinaryCrossentropy(),
                  metrics=METRICS)
    return model

# Train the model
def train_model(model, dataset, epochs, label_name, batch_size=None, shuffle=True):
    features = {name: np.array(value) for name, value in dataset.items()}
    label = np.array(features.pop(label_name))
    history = model.fit(x=features, y=label, batch_size=batch_size, epochs=epochs, shuffle=shuffle, verbose=0)
    epochs = history.epoch
    hist = pd.DataFrame(history.history)
    return epochs, hist

# Define hyperparameters and metrics
learning_rate = 0.001
epochs = 30
batch_size = 100
label_name = "median_house_value_is_high"
classification_threshold = 0.35
METRICS = [
    tf.keras.metrics.BinaryAccuracy(name='accuracy', threshold=classification_threshold),
    tf.keras.metrics.Precision(thresholds=classification_threshold, name='precision'),
    tf.keras.metrics.Recall(thresholds=classification_threshold, name='recall'),
    tf.keras.metrics.AUC(name='auc')
]

# Create and train the model
my_model = create_model(inputs, learning_rate, METRICS)
epochs, hist = train_model(my_model, train_df_norm, epochs, label_name, batch_size)

# Evaluate model on test set
features = {name: np.array(value) for name, value in test_df_norm.items()}
label = np.array(features.pop(label_name))
y_pred_prob = my_model.predict(features)

# Calculate ROC curve and AUC
fpr, tpr, _ = roc_curve(label, y_pred_prob)
roc_auc = auc(fpr, tpr)

# Print final metric values
print(f"Final Metric Values - AUC: {roc_auc:.3f}")

# Plot ROC curve
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (area = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic Example')
plt.legend(loc='lower right')
plt.show()
